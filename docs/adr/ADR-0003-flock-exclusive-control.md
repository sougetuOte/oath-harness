# ADR-0003: flock による排他制御戦略

**Status**: Accepted
**Date**: 2026-02-23
**Context**: oath-harness Phase 1 (MVP)

## Context

oath-harness は `trust-scores.json` や監査ログなどの JSON ファイルへの同時アクセスが発生しうる。
特に Claude Code の hooks は複数の操作がほぼ同時に発火することがあり、
排他制御なしでは JSON の破損（部分書き込みによる不正な JSON）が起きる可能性がある。

排他制御の選択肢として以下を検討した:

| 手段 | 特徴 |
|------|------|
| `flock` コマンド | POSIX準拠、追加依存なし、bash ネイティブ |
| ロックファイル（`*.lock`） | 実装が複雑、古典的競合状態のリスク |
| データベース（SQLite 等） | 過剰、bash からの利用が煩雑 |
| アトミックリネーム（`mv`） | 書き込みには有効だが読み込みの整合性が保証されない |

## Decision

**`flock` コマンドによるファイルレベルの排他制御を採用する。**

実装パターン:

```bash
# 読み書きの排他制御（タイムアウト付き）
(
  flock --exclusive --timeout 5 200 || {
    echo "ERROR: ロック取得タイムアウト" >&2
    exit 1
  }
  # クリティカルセクション
  jq '...' "${state_file}" > "${state_file}.tmp" && mv "${state_file}.tmp" "${state_file}"
) 200>"${state_file}.lock"
```

- ロックファイルは `<対象ファイル>.lock` とする
- タイムアウトは 5 秒を標準とし、環境変数 `OATH_LOCK_TIMEOUT` で上書き可能とする
- 書き込みは必ず「一時ファイルへの書き込み → アトミックリネーム」パターンを使用する

## Consequences

### Positive

- POSIX 準拠のため、Linux / macOS の両環境で追加インストールなしに動作する
- bash の標準機能と自然に統合でき、実装がシンプル
- タイムアウトを設定することでデッドロックを自動解除できる
- カーネルレベルのロックであるため、プロセス終了時に自動解放される

### Negative

- ファイルシステムへの書き込みが発生するため、微小なパフォーマンスオーバーヘッドがある
  （実測では 1〜5ms 程度と推定）
- ロックファイル（`*.lock`）がリポジトリに残ることがあり、`.gitignore` への追加が必要

### Risks

- タイムアウト時間（5秒）内にクリティカルセクションが完了しない場合、
  後続プロセスがエラー終了するリスクがある
  - 緩和策: クリティカルセクション内の処理は最小限に保ち、重い計算は外で行う
- NFS マウントされたディレクトリでは `flock` が正しく動作しない場合がある
  - 緩和策: oath-harness の状態ファイルをローカルパスに配置することを前提とし、
    NFS 上での使用はサポート対象外とする
- ロックファイルの残留により、異常終了後に次の実行がハングする可能性がある
  - 緩和策: プロセス終了時（`trap` による）にロックファイルをクリーンアップする
